#' Plot genome-wide statistics
#'
#'This function will plot the results from genome-wide analyses of diversity,
#'association, etc., that can be generated by a small variety of programs. As
#'of 2019-01, it will handle any tibbles produced by the file_loading_functions.
#'
#' @param input A tibble with four columns (scaf, ps, stat, and chr)
#' @param type Type of input: gwas, popgen. gwas will -log10 the stat, while
#'     popgen will estimate the ylimits.
#' @param scaffold_lengths Name of a two-column tab delimited file with
#'     scaffold and length.
#' @param plotting_column Name of the column to plot. Usually will be 'stat'
#' @inheritParams get_cumulative_positions
#' @inheritParams ggplot2
#' @return  A ggplot object that can be printed to file.
#' @export
#'
#' @examples
#' a1 <- system.file("extdata", "test.gemma_gwas.txt.gz",
#'                  package = "gwplotting")
#' a2 <- system.file("extdata", "test.chromSizes.txt.gz",
#'                   package="gwplotting")
#'
#' b <- load_gemma_gwas( a1, pval = 'p_wald' )
#'
#' c <- plot_genomewide_data( b, type = 'gwas', scaffold_lengths = a2,
#'                            plotting_column = 'stat')
#' c
plot_genomewide_data <- function( input, type = 'gwas', scaffold_lengths,
                                  plotting_column = 'stat' ){

  # Take care of GWAS ----------------------------------------------------------
  if( type == 'gwas' ){

    message("--Getting FDR values...\n")

    pvals.adj <- p.adjust( input$stat, method = 'fdr' )
    x <- cbind( input$stat, pvals.adj )
    x <- x[ order( x[ , 'pvals.adj'], decreasing = T ), ]
    p10 <- -log10(head( x[ x[ , 'pvals.adj' ] <= 0.1, ], n = 1 )[1])
    p01 <- -log10(head( x[ x[ , 'pvals.adj' ] <= 0.01, ], n = 1 )[1])

    cat( paste0("--10% and 1% cutoffs are ",p10," and ",p01,"\n") )
    # Significance lines
    sigLines <- list(ggplot2::geom_hline( ggplot2::aes( yintercept = p10 ),
                                          color = 'blue', alpha = 0.50,
                                          linetype = 'dashed'),
                     ggplot2::geom_hline( ggplot2::aes( yintercept = p01 ),
                                          color = 'red', alpha = 0.50,
                                          linetype = 'dashed' ))

    # Reduce gwas and plot size
    input <- filter( input, stat <= 0.05 )
    input$stat <- -log10(input$stat)

    ylimits <- c( 0, ceiling(max(input$stat, na.rm = T ) / 5) * 5 )

  } else {

    sigLines <- NA

    mns <- min( input[, plotting_column ], na.rm = T )
    mxs <- max( input[, plotting_column ], na.rm = T )
    ylimits <- c( mns - 0.1 * mns, mxs + 0.1 * mxs )

  }

  # Get cumulative positions ---------------------------------------------------
  input <- get_cumulative_positions( input, scaffold_lengths = scaffold_lengths,
                                     buffer = 20000, after = 'chromosomes' )

  # Plotting -------------------------------------------------------------------

  # Find tickmarks for x-axis
  axisdf <- input %>% dplyr::group_by( chr ) %>%
    dplyr::summarize( center = ( max(bp_cum) + min(bp_cum) ) / 2 )

  num_chr <- nrow( axisdf )

  for_plot <- ggplot2::ggplot( input,
                               ggplot2::aes_string( x = "bp_cum" , y = plotting_column)) +

    # Show all points
    ggplot2::geom_point( ggplot2::aes( color = factor( input$chr, levels = unique( input$chr )) ),
                         alpha = 0.75 , size = 1 ) +
    ggplot2::scale_color_manual( values = rep(c("grey", "black"), ceiling( num_chr/2 ) ,
                                              length = num_chr )) +

    # custom X axis:
    ggplot2::scale_x_continuous( breaks = axisdf$center, expand = c( 0.005, 0 ),
                                 labels = axisdf$chr,
                                 name = 'Chromosome'  ) +
    ggplot2:: scale_y_continuous( expand = c( 0.05, 0 ), limits = ylimits ) +
    # remove space between plot area and x axis

    # Customize the theme:
    ggplot2::theme_bw() +
    ggplot2::theme(
      legend.position="none",
      panel.border = ggplot2::element_blank(),
      panel.grid.major.x = ggplot2::element_blank(),
      panel.grid.minor.x = ggplot2::element_blank(),
      axis.ticks = ggplot2::element_blank(),
      axis.text = ggplot2::element_text( size = 6 ),
      # axis.text.x = ggplot2::element_text( angle = 35 , vjust = 1.25, hjust = 0.95 ),
      #axis.text.x = ggplot2::element_blank(),
      axis.title = ggplot2::element_text( size = 8 )
    )

  if( is.list( sigLines ) ){
    for_plot <- for_plot + sigLines
  }
  return( for_plot )
}


#' Plot statistics for a particular region
#'
#' This is a function to plot statistics on a particular scaffold or chromosome,
#' or in a particular region of that scaffold or chromosome. The input may be 1)
#' the raw tibble from any of the loading functions, 2) a reordered tibble, or
#' 3) a tibble with cumulative positions. This function will operate differently
#' on each of these input types. If the input already has cumulative positions
#' (i.e. column bp_cum), the the "from" and "to" variables are interpreted as
#' "from = bp_cum start" and "to = bp_cum end". If the input does not have
#' column bp_cum, then this function will generate bp_cum according to the
#' desired chromosome or scaffold, assume that the supplied "from" and "to"
#' arguments are scaffold positions, and determine the appropriate "from" and
#' "to" coordinates from the new bp_cum coordinates. You may only specify a
#' chromosome OR a scaffold.
#'
#' @param input A tibble
#' @param chromosome Chromosome to plot. This will be coded in the "chr"
#'     column of your tibble. This or scaffold may be specified.
#' @param scaffold Scaffold to plot. This will be coded in the "scaf" column
#'     of your tibble. This or chromosome may be specified.
#' @param from Start position, if desired.
#' @param to End position, if desired
#' @param type Type of statistic: gwas, popgen.
#' @param plotting_column Name of the column to plot. Usually will be 'stat'
#' @param scaffold_lengths Name of a two-column tab delimited file with
#'     scaffold and length.
#' @inheritParams ggplot2
#'
#' @return A ggplot2 object containing the plot.
#' @export
#'
#' @examples
#' a1 <- system.file("extdata", "test.gemma_gwas.txt.gz",
#'                  package = "gwplotting")
#' a2 <- system.file("extdata", "test.chromSizes.txt.gz",
#'                   package="gwplotting")
#'
#' b <- load_gemma_gwas( a1, pval = 'p_wald' )
#' chrom <- b$chr[ b$scaf == "scaffold_1000" ][1]
#'
#' c <- plot_region_data( b, chromosome = chrom, type = 'gwas',
#' plotting_column = 'stat', scaffold_lengths = a2)
#' c
plot_region_data <- function( input, chromosome = NA, scaffold = NA, from = 1, to = NA, type,
                              plotting_column = 'stat', scaffold_lengths,
                              include_all_p = FALSE ){

  # Check scaffold / chromosome ------------------------------------------------
  if( ! is.na( scaffold ) & ! is.na( chromosome )){
    message("ERROR: cannot specify both chromosome and scaffold")
    break
  } else if( is.na( scaffold ) & is.na( chromosome ) ){
    message("ERROR: you must specify a chromosome or a scaffold")
    break
  } else if( ! is.na( scaffold ) ){

    # Want a scaffold, so from and to should be in terms of ps
    if( is.na( to )  ){ # Get just a small region
      input <- dplyr::filter( input, scaf == scaffold )
    } else {
      input <- dplyr::filter( input, scaf == scaffold, ps >= from, ps <= to )
    }

  } else {

    # Get chr of interest
    input <- dplyr::filter( input, chr == chromosome )

    # Handle from and to when bp_cum is not present
    if( ! "bp_cum" %in% colnames( input ) ){

      # If there's only one scaffold for this chromosome, obviously
      # don't need to shift positions
      if( length( unique( input$scaf ) ) == 1 ){
        input <- mutate( input, bp_cum = ps )
      } else {
        input <- get_cumulative_positions( input, scaffold_lengths = scaffold_lengths,
                                           buffer = 0, after = 'scaffolds')
      }
    }

    # If you want a subregion,
    if( ! is.na( to ) ){
      input <- dplyr::filter( input, bp_cum >= from, bp_cum <= to )
    }
  }

  # Take care of GWAS ----------------------------------------------------------
  if( type == 'gwas' ){

    # Reduce gwas and plot size
    if( ! include_all_p ){
      input <- filter( input, stat <= 0.05 )
    }

    input$stat <- -log10(input$stat)
    ylimits <- c( 0, ceiling(max(input$stat, na.rm = T ) / 5) * 5 )

  } else {
    mns <- min( input[,  plotting_column ], na.rm = T )
    mxs <- max( input[, plotting_column ], na.rm = T )
    ylimits <- c( mns - 0.1 * mns, mxs + 0.1 * mxs )
  }


  # Plotting -------------------------------------------------------------------

  for_plot <- ggplot2::ggplot( input,
                               ggplot2::aes_string( x = "bp_cum" , y = plotting_column, fill = '"black"' )) +

    # Show all points
    ggplot2::geom_point( alpha = 0.75 , size = 1  ) +

    # custom X axis:
    ggplot2::scale_x_continuous( expand = c( 0.005, 0 ),
                                 name = paste( "chromosome", chromosome, sep = ' ' )  ) +
    ggplot2:: scale_y_continuous( expand = c( 0.05, 0 ), limits = ylimits ) +

    # Customize the theme:
    ggplot2::theme_bw() +
    ggplot2::theme(
      legend.position="none",
      panel.border = ggplot2::element_blank(),
      panel.grid.major.x = ggplot2::element_blank(),
      panel.grid.minor.x = ggplot2::element_blank(),
      axis.ticks = ggplot2::element_blank(),
      axis.text = ggplot2::element_text( size = 6 ),
      # axis.text.x = ggplot2::element_text( angle = 35 , vjust = 1.25, hjust = 0.95 ),
      #axis.text.x = ggplot2::element_blank(),
      axis.title = ggplot2::element_text( size = 8 )
    )

  return( for_plot )

}


